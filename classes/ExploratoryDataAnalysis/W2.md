#The lattice plotting system
- `library(lattice)` Trellis graphics independent of the base graphic system.
 - `xyplot`, `bwplot`, `levelplot`
- `grid`: lattice builds on top of grid, rarelly `grid` functions are called.
- Plotting and annotation is done at once with a single function call.

###Lattice functions
- `xyplot` to create scatterplots
- `bwplot` boxplots
- `histogram`
- `stripplot` like a boxplot with actual plots
- `dotplot` plot dots on 'violin strings'
- `splom` scatterplot matrix; like `pairs` in base plotting system
- `levelplot`, `contourplot` for plotting 'image' data

The `xyplot(y ~ x | f * g, data)` call will have the following params.
- We use the *formula notation*, hence the `~`
- On the left of the `~` is the y-axis, and x-axis on the right.
- `f` and `g` are *conditioning variables* (optional), the * indicates
  interation between the two variables.
- `data` is the data frame where x, y, f, and g can be found. No data param then
   the parent frame (workspace) is used.
- There are defaults in place.

```R
library(lattice)
library(datasets)
xyplot(Ozone ~ Wind, data=airquality)

airquality <- transform(airquality, Month = factor(Month))
xplot(Ozone ~ Wind | Month, data = airquality, layout = c(5, 1))
```

The advantage of lattice is that these multidimensional plot can be done very
simply with just a function call. When comparing to the base plotting system
that will require many functions.

###Lattice behavior
- Base graphic system plots data directly to the graphic device (screen, file,
  etc.)
- The lattice graphic function return an object of type **trellis**
- The print methods for lattice function do the work of plotting in the graphic
  device.
- The lattice functions return a 'plot object' that can, in principle, be
  stored, but it's better to only save the code and data.
- On the command line, trellis objects are *auto-printed*, meaning we see
  a plot.

```R
p <- xyplot(Ozone ~ Wind, data = airquality) # Nothin happens
print(p) # plot appears

xyplot(Ozone ~ Wind, data = airquality) # Auto print.
```

#The lattice plotting system
Each panel is going to represent a subset of the data, which is defined by the
conditioning variable that you give it.

- lattoce functions have a panel function that controls what happen in each
  panel.
- The lattice package defines defaults but we can add our own.
- The lattice system is ideal for creating conditioning plots where you examine
  the same kind of plot under many different conditions.
- Other function in the lattice package include `bwplot`,  `boxplot`,
  `scatter`.

```R
set.seed(10)
x <- rnorm(100)
f <- rep(0:1, each=50)
y <- x + f - f * x + rnorm(100, sd=0.5)
f <- factor(f, labels = c('Group 1', 'Group 2'))
xyplot(y ~ x | f, layout = c(2, 1)) # PLot with 2 panels

# calling custom functions
xyplot(y ~ x | f, panel = function(x, y, ...) {
    # this will apply to each factor f.
    panel.xyplot(x, y, ...) # Render the panels
    panel.abline(h = median(y), lty=2) # horizontal dash line at the median.
}, layout=c(2, 1)) # I don't need to add the layout param since its the
                   # default behavior

xyplot(y ~ x | f, panel = function(x, y, ...) {
    panel.xyplot(x, y, ...) # renders the plots
    panel.lmline(x, y, col=2) # overlays a simple linear regression line.
})
```
